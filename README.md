## SJTU-ICS-2017 lab6 partC攻略 
### 常规步骤
#### 修改hcl，增加iaddq指令  
* 在很多时候加减数不需要先mv到寄存器了，同时，具备刷新cc的能力，省去andq。  
* iaddq $-1, 类似是可行的
#### 修改ncopy.ysa
* 多重循环展开，展开越多速度越快，本质上是减少了指针移动
* 避免mr和rm连写，也就是避免数据冒险
* 多重循环后，一重循环可以去掉末尾指针移动
* 注意jxx的方向，通过调整指令，使得总是跳跃到概率大的地方（数据数量是1到64）
* 到这一步，基本上可以拿到50分以上

### 极限操作之一：多重展开
* 采用8+2+1循环展开，或者9+2+1展开
* 该方法的核心在于，收尾的是2+1展开，因为类似的8+4+2，难以抹去指针移动
* 采用了多重循环组合之后，基本上有55分左右（8+4和8+2均可）

### 极限操作之二：省略末尾移动
* 说起来比较简单，就是抹掉所有循环的末尾指针移动
* 比如说我有20个数据，在程序跑完的时候，指针停留在第20个数据的前面，第19个数据的后面  
也就是说，省掉最后一次
* 具体到如何省掉的呢？类似于将指针增加操作移动到loop开头，设置两个不同的label  
第一次进入循环的时候，跳到下面的label，循环末尾的判断，跳回到高位的label，这样，  
在最后一次循环结束时候，指针就没有移动。
* 那么，为什么说9+2+1是最极限的呢，原因如下：

### 极限操作之三：抹去所有末尾移动
* 我要抹掉9循环的末尾移动，那么，9循环结束后，到2循环的时候，指针并不在末尾位置，  
这样就乱了，如何解决这个问题？
* 方案如下：复制一遍二重循环代码，等于说，制造了两个二重循环，一个对应着，指针从末尾开始，  
另一个对应着，指针差了9个数据点，同理，制造四个一重收尾循环，收尾其实不算做循环了，  
因为要么做一次copy，要么直接结束，所以指令数极其少
* 如此，举例比如说，16个数据，原本是9+2+2+2+1，意味着我做了五次指针移动，并且还有一定的  
控制预测错误，但是，经过抹去操作，我实际上只用了 2+2，两次指针移动，  
每次指针移动两条add语句，就是2个周期，等于说，一波赚了6个周期，而类似的不能被完整结束的  
数据点很多，总体下来，性能提升了。
* 到这一步，有58.4分（适当调整三个循环的进入顺序，预测概率大的方向）

### 极限操作之四： 去掉xorq
* 第一句的初始化rax可以去掉，因为这个程序比较简单，它就是0，不会引发错误
* 但这也不算是一个好的操作，总之可以拿分就是
* 到这一步，59.8分

### 极限操作之五： 单重循环数据冒险
* 单重循环指令数很少，少到找不到指令填充mr和rm之间的间隙，但因为这个运行次数不多，  
损失一个周期无关痛痒
* 但计数程序的设计上，开头几个权值很大，并且，0不计数
* 于是，极限操作应运而生，四个一重循环中的，唯一一个对应，只有一个数据点的那个循环，  
先mr，再jxx，赚回一个周期，同时在0的位置上损失一个周期
* 由于0不计数，1的位置权值很大，1个周期直接满分
* 最后，CPE=7.49 score=60  

![Aaron Swartz](https://raw.githubusercontent.com/Veiasai/ics-2017-lab6/master/QQ%E5%9B%BE%E7%89%8720171219125116.png)

### 程序漏洞
* 通过简单的几行代码...可以骗过所有测试...并且使得计数程序异常
* 最终效果几乎是可以控制CPE的结果，从0.44到更大的值，均可以人为制造
* 假如不人工检查代码，只看平均值，造一个7.48瞒天过海...
* 但这个骚操作我告知了Ta
* 而且也不打算公开..噗..放两张图好了
![Aaron Swartz](https://raw.githubusercontent.com/Veiasai/ics-2017-lab6/master/QQ%E5%9B%BE%E7%89%8720171219124822.png)
![Aaron Swartz](https://raw.githubusercontent.com/Veiasai/ics-2017-lab6/master/QQ%E5%9B%BE%E7%89%8720171219124831.png)